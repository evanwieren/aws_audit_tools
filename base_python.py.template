# This will connnect to an AWS account and provide a report of resources that
# are not in compliance. 

from __future__ import print_function
import os
import logging
import traceback
import boto3

LOG_LEVELS = {'CRITICAL': 50, 'ERROR': 40, 'WARNING': 30, 'INFO': 20, 'DEBUG': 10}


def init_logging():
    # Setup loggin because debugging with print can get ugly.
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    logging.getLogger("boto3").setLevel(logging.WARNING)
    logging.getLogger('botocore').setLevel(logging.WARNING)
    logging.getLogger('nose').setLevel(logging.WARNING)

    return logger


def setup_local_logging(logger):
    # Set the Logger so if running locally, it will print out to the main screen.
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s %(name)-12s %(levelname)-8s %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG)

    return logger


def set_log_level(logger, log_level = 'INFO'):
    # There is some stuff that needs to go here.
    if log_level in LOG_LEVELS:
        logger.setLevel(LOG_LEVELS[log_level])
    else:
        logger.setLevel(LOG_LEVELS['INFO'])

    return logger

def process_global_vars():
    logger.info("Processing variables from environment.")
    try:
        global REPORTING_TABLE
        REPORTING_TABLE = os.environ.get('REPORTING_TABLE', REPORTING_TABLE)
        if REPORTING_TABLE is '':
            logger.error("REPORTING_TABLE must not be blank.\n\tPlease configure the environment variable.")
            sys.exit(1)
        logger.debug("REPORTING_TABLE set to %s" % REPORTING_TABLE)
        global REPORTING_TABLE_REGION
        REPORTING_TABLE_REGION = os.environ.get('REPORTING_TABLE_REGION', REPORTING_TABLE_REGION)
        logger.debug("REPORTING_TABLE_REGION set to %s" % REPORTING_TABLE_REGION)
        global REPORT_START_DATE
        REPORT_START_DATE = os.environ.get('REPORT_START_DATE', SET_DATE_MARKER)
        REPORT_START_DATE = set_date(REPORT_START_DATE)
        logger.debug("REPORT_START_DATE set to %s" % str(REPORT_START_DATE))
        global REPORT_END_DATE
        REPORT_END_DATE = os.environ.get('REPORT_END_DATE', SET_DATE_MARKER)
        REPORT_END_DATE = set_date(REPORT_END_DATE)
        logger.debug("REPORT_END_DATE set to %s" % str(REPORT_END_DATE))
        global S3_REPORT_BUCKET
        S3_REPORT_BUCKET = os.environ.get('S3_REPORT_BUCKET', "ERROR")
        if S3_REPORT_BUCKET is "ERROR":
            logger.error("S3_REPORT_BUCKET cannot be left blank.")
            sys.exit(1)
        logger.debug("Completed execution of process_global_vars")
    except SystemExit:
        sys.exit(1)
    except:
        logger.error("Unexpected error!\n Stack Trace:", traceback.format_exc())

def lambda_handler(event, context):
    try:
        global logger
        logger = init_logging()
        logger = set_log_level(logger, os.environ.get('log_level', 'INFO'))

        logger.debug("Running function lambda_handler")

        # Do stuff now

    except SystemExit:
        logger.error("Exiting")
        sys.exit(1)
    except ValueError:
        exit(1)
    except:
        print ("Unexpected error!\n Stack Trace:", traceback.format_exc())
    exit(0)


if __name__ == "__main__":
   logger = init_logging()
   logger = setup_local_logging(logger)

   event = {'log_level': 'INFO'}
   os.environ['log_level'] = os.environ.get('log_level', "INFO")

   # Add default level of debug for local execution
   lambda_handler(event, 0)